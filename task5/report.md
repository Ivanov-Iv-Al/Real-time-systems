# Отчет по лабораторной работе: Управление памятью в Linux

## Студент: [Ваше ФИО]
## Группа: [Номер группы]
## Дата: [Дата выполнения]

---

## 1. Введение

Цель данной работы - исследование механизмов управления памятью в операционной системе Linux, в частности:
1. Демонстрация влияния page faults на задержки доступа к памяти
2. Использование `mlockall()` для предотвращения page faults
3. Реализация пула памяти с предсказуемым временем доступа

## 2. Задание 1: Демонстрация влияния Page Faults

### 2.1 Методика эксперимента
- Выделен массив размером 512 МБ
- Выполнено 1000 итераций доступа к памяти с шагом 4096 байт
- На каждой итерации измерялись:
  - Латентность доступа (`clock_gettime()`)
  - Количество minor и major page faults (`getrusage()`)

### 2.2 Результаты

![График латентности](task1_results.png)

**Таблица 1: Статистика по Task 1**
| Параметр | Значение |
|----------|----------|
| Средняя латентность | [значение] нс |
| Максимальная латентность | [значение] нс |
| Минимальная латентность | [значение] нс |
| Стандартное отклонение | [значение] нс |
| Общее количество minor faults | [значение] |
| Общее количество major faults | [значение] |

### 2.3 Анализ результатов
- **Пики латентности**: Наблюдаются на итерациях, где происходят page faults
- **Minor faults**: Возникают при первом обращении к странице, которая выделена, но не загружена в RAM
- **Major faults**: В данном эксперименте обычно равны 0, так как память не вытесняется на диск

---

## 3. Задание 2: Устранение Page Faults с помощью mlockall

### 3.1 Модификации программы
1. Добавлен вызов `mlockall(MCL_CURRENT | MCL_FUTURE)` в начале программы
2. Реализован "прогрев" памяти перед измерениями
3. Программа запускается с правами суперпользователя

### 3.2 Результаты

**Таблица 2: Сравнение Task 1 и Task 2**
| Параметр | Task 1 (без mlock) | Task 2 (с mlock) | Улучшение |
|----------|-------------------|------------------|-----------|
| Средняя латентность | [значение] нс | [значение] нс | [значение]% |
| Максимальная латентность | [значение] нс | [значение] нс | [значение]% |
| Стандартное отклонение | [значение] нс | [значение] нс | [значение]% |
| Page faults | [значение] | 0 | 100% |

### 3.3 Выводы
- `mlockall()` полностью исключает page faults
- Латентность становится стабильной и предсказуемой
- Необходимость в правах суперпользователя ограничивает применение

---

## 4. Задание 3: Реализация пула памяти

### 4.1 Архитектура пула
- **`pool_create()`**: Выделяет и блокирует память с помощью `mlock()`
- **`pool_alloc()`**: O(1) - извлечение из списка свободных блоков
- **`pool_free()`**: O(1) - возврат в список свободных блоков
- **`pool_destroy()`**: Освобождение всей памяти пула

### 4.2 Результаты бенчмарка

**Таблица 3: Сравнение производительности**
| Система | Максимальная латентность | Средняя латентность | Стандартное отклонение |
|---------|-------------------------|---------------------|------------------------|
| malloc/free | [значение] нс | [значение] нс | [значение] нс |
| pool_alloc/pool_free | [значение] нс | [значение] нс | [значение] нс |

### 4.3 Анализ
- **Пул памяти**:
  - Предсказуемое время выделения/освобождения
  - Отсутствие фрагментации
  - Ограничение: фиксированный размер блоков
  
- **malloc/free**:
  - Больший разброс времени выполнения
  - Риск фрагментации памяти
  - Универсальность (любой размер)

---

## 5. Ответы на контрольные вопросы

### 5.1 Почему для `mlockall` требуются права суперпользователя?