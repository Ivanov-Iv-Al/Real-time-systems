# Отчет по работе с устройствами ввода Linux

## Контрольные вопросы

### 1. В чем принципиальное отличие символьных устройств от блочных? Приведите по два примера каждого типа.

**Символьные устройства:**
- Обеспечивают небуферизованный потоковый доступ к данным
- Операции чтения/записи выполняются последовательно
- Примеры: 
  - `/dev/input/eventX` - устройства ввода (клавиатура, мышь)
  - `/dev/ttyS0` - последовательный порт

**Блочные устройства:**
- Обеспечивают доступ к данным блоками фиксированного размера
- Поддерживают буферизацию и кэширование
- Позволяют произвольный доступ к данным
- Примеры:
  - `/dev/sda1` - раздел жесткого диска
  - `/dev/sr0` - CD/DVD привод

### 2. Почему для ожидания событий от нескольких источников данных poll() является предпочтительнее, чем busy-wait цикл? Опишите сценарий, где это критически важно.

**Преимущества poll():**
- Эффективное использование CPU: процесс блокируется до появления событий
- Масштабируемость: может отслеживать множество файловых дескрипторов
- Избегает активного ожидания, снижая нагрузку на систему

**Критический сценарий:**
Сервер, обрабатывающий множество сетевых соединений. Использование busy-wait привело бы к 100% загрузке CPU даже при отсутствии данных, что недопустимо для серверных приложений.

### 3. Может ли вызов read() для символьного устройства заблокировать процесс? Если да, то как этого избежать?

**Да**, вызов `read()` может блокировать процесс в следующих случаях:
- Данные временно недоступны (буфер пуст)
- Устройство находится в состоянии ожидания

**Способы избежать блокировки:**
1. Использовать флаг `O_NONBLOCK` при открытии устройства
2. Использовать `select()` или `poll()` для проверки доступности данных перед чтением
3. Использовать асинхронный I/O с сигналами

### 4. Объясните, почему для работы с ioctl и структурами из /dev/input/ требуются специфичные для Linux заголовочные файлы. Является ли такой код переносимым на другие POSIX-системы?

**Причины:**
- `ioctl` команды (EVIOCGNAME, EVIOCGPHYS) определены в заголовочных файлах ядра Linux
- Структура `struct input_event` специфична для подсистемы ввода Linux
- Номера и семантика ioctl-команд различаются между системами

**Переносимость:**
Код, использующий специфичные для Linux ioctl-команды и структуры, **не является переносимым** на другие POSIX-системы. Каждая система (macOS, FreeBSD) имеет свои собственные интерфейсы для работы с устройствами ввода. Для создания переносимого кода потребовалось бы использовать абстракции или условную компиляцию.

## Заключение

В ходе работы были успешно реализованы программы для мониторинга устройств ввода в Linux, изучены особенности работы с символьными устройствами и механизмами многозадачного I/O.