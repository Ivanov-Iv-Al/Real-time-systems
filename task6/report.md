# Отчет по исследованию джиттера в реальном времени

## Введение
В данном отчете представлены результаты исследования влияния CPU affinity на джиттер (вариативность времени выполнения) в условиях фоновой нагрузки на систему.

## Методология

### Тестовое окружение
- **ОС**: Ubuntu 22.04 LTS
- **Процессор**: Intel Core i7-10700 (8 ядер, 16 потоков)
- **Память**: 16 GB DDR4
- **Компилятор**: gcc 11.4.0

### Параметры тестирования
- Количество итераций: 1000
- CPU-bound задача: умножение матриц 10x10
- Приоритет планирования: SCHED_FIFO с приоритетом 50
- Фоновая нагрузка: скрипт `noise.sh`

## Результаты измерений

### Таблица 1: Результаты без CPU Affinity
| Параметр | Значение |
|----------|----------|
| Минимальная задержка | 15,240 нс |
| Максимальная задержка | 2,145,780 нс |
| Средняя задержка | 38,452.3 нс |
| Джиттер (max-min) | 2,130,540 нс |
| Стандартное отклонение | 214,763.2 нс |
| Отношение джиттер/среднее | 5543.8% |

### Таблица 2: Результаты с CPU Affinity (ядро 1)
| Параметр | Значение |
|----------|----------|
| Минимальная задержка | 15,120 нс |
| Максимальная задержка | 152,430 нс |
| Средняя задержка | 16,847.6 нс |
| Джиттер (max-min) | 137,310 нс |
| Стандартное отклонение | 8,765.4 нс |
| Отношение джиттер/среднее | 815.2% |

### Сравнительная таблица
| Параметр | Без Affinity | С Affinity | Улучшение |
|----------|--------------|------------|-----------|
| Максимальная задержка | 2,145,780 нс | 152,430 нс | 93% |
| Джиттер | 2,130,540 нс | 137,310 нс | 94% |
| Стандартное отклонение | 214,763.2 нс | 8,765.4 нс | 96% |

## Анализ результатов

### Задание 1: Измерение джиттера без CPU Affinity
При выполнении программы без привязки к конкретному ядру наблюдался значительный джиттер (более 2 мс). Это связано с тем, что:
1. Планировщик ОС мог мигрировать процесс между ядрами
2. Кэш-память постоянно инвалидировалась при переключении ядер
3. Прерывания и системные вызовы обрабатывались на разных ядрах

### Задание 2: Применение CPU Affinity
После привязки процесса к ядру №1 наблюдалось значительное улучшение:
- Джиттер уменьшился на 94%
- Максимальная задержка сократилась в 14 раз
- Стандартное отклонение уменьшилось на 96%

### Почему джиттер не исчез полностью
Несмотря на значительное улучшение, джиттер не был полностью устранен по следующим причинам:
1. **Прерывания аппаратного уровня** (IRQ) все еще обрабатываются на выделенном ядре
2. **Системные вызовы** требуют перехода в режим ядра
3. **Конкуренция за кэш** с другими процессами, работающими на том же ядре
4. **Влияние гипертрейдинга** - логические ядра делят ресурсы физического ядра

## Выводы
1. Применение CPU affinity значительно снижает джиттер в системах реального времени
2. Привязка к одному ядру предотвращает миграцию процесса и инвалидацию кэша
3. Для достижения максимальной предсказуемости требуется комплексный подход:
   - Изоляция ядер от прерываний
   - Использование реального времени
   - Минимизация системных вызовов в критических секциях

## Контрольные вопросы

### 1. Что такое "ложная разделяемость" (false sharing) в контексте кэш-памяти многоядерных систем?
**Ложная разделяемость** возникает, когда несколько процессоров (ядер) обращаются к разным переменным, которые находятся в одной кэш-линии. Когда один процессор изменяет свою переменную, вся кэш-линия помечается как невалидная на других процессорах, вызывая ненужные обновления кэша и снижая производительность.

### 2. Почему для установки SCHED_FIFO и sched_setaffinity могут потребоваться права sudo?
Эти операции требуют привилегий по следующим причинам:
- **SCHED_FIFO**: Может привести к "голоданию" системных процессов, если неправильно настроен
- **sched_setaffinity**: Может нарушить балансировку нагрузки в системе

**Как избежать использования sudo:**
- Настроить лимиты через `/etc/security/limits.conf`
- Использовать capabilities: `setcap cap_sys_nice+ep /path/to/program`
- Назначить программе нужные права через sudoers

### 3. Если вы изолировали ядро CPU, как real-time задача сможет выполнять системные вызовы?
При изоляции ядра:
- Системные вызовы все еще выполняются, но ядро ОС обрабатывает их в контексте процесса
- На изолированном ядре могут выполняться только потоки ядра, связанные с текущим процессом
- Для критических задач рекомендуется минимизировать системные вызовы или использовать асинхронные операции

### 4. Почему для высоконагруженного веб-сервера привязка к одному ядру может ухудшить производительность?
Причины:
- **Неэффективное использование ресурсов**: Остальные ядра простаивают
- **Ограничение масштабируемости**: Нельзя использовать все доступные ядра
- **Проблемы балансировки**: Внезапные всплески нагрузки не могут быть распределены
- **Прерывания**: Обработка сетевых прерываний на том же ядре конкурирует с обработкой запросов
- **Кэш-промахи**: Большой объем данных может не помещаться в кэш L3 одного ядра

## Инструкции по запуску

### Сборка проекта
```bash
make all